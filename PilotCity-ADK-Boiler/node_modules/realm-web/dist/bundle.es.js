import { EJSON } from 'bson';

////////////////////////////////////////////////////////////////////////////
/**
 * Serialize an object containing BSON types into extended-JSON.
 *
 * @param obj The object containing BSON types.
 * @returns The document in extended-JSON format.
 */
function serialize(obj) {
    return EJSON.serialize(obj);
}
/**
 * De-serialize an object or an array of object from extended-JSON into an object or an array of object with BSON types.
 *
 * @param obj The object or array of objects in extended-JSON format.
 * @returns The object or array of objects with inflated BSON types.
 */
function deserialize(obj) {
    if (Array.isArray(obj)) {
        return obj.map(doc => EJSON.deserialize(doc));
    }
    else {
        return EJSON.deserialize(obj);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * A list of names that functions cannot have to be callable through the functions proxy.
 */
const RESERVED_NAMES = ["inspect", "callFunction"];
/**
 * Remove the key for any fields with undefined values.
 *
 * @param args The arguments to clean.
 * @returns The cleaned arguments.
 */
function cleanArgs(args) {
    for (const arg of args) {
        if (typeof arg === "object") {
            for (const [key, value] of Object.entries(arg)) {
                if (value === undefined) {
                    delete arg[key];
                }
            }
        }
    }
    return args;
}
/**
 * Remove keys for any undefined values and serialize to EJSON.
 *
 * @param args The arguments to clean and serialize.
 * @returns The cleaned and serialized arguments.
 */
function cleanArgsAndSerialize(args) {
    const cleaned = cleanArgs(args);
    return cleaned.map(arg => (typeof arg === "object" ? serialize(arg) : arg));
}
/**
 * Defines how functions are called.
 */
class FunctionsFactory {
    /**
     * Construct a functions factory.
     *
     * @param transport The underlying transport to use when sending requests.
     * @param config Additional configuration parameters.
     */
    constructor(transport, config = {}) {
        this.transport = transport;
        this.serviceName = config.serviceName;
        this.argsTransformation =
            config.argsTransformation || cleanArgsAndSerialize;
        this.responseTransformation =
            config.responseTransformation || deserialize;
    }
    /**
     * Create a factory of functions, wrapped in a Proxy that returns bound copies of `callFunction` on any property.
     *
     * @param transport The underlying transport to use when requesting.
     * @param config Additional configuration parameters.
     * @returns The newly created factory of functions.
     */
    static create(transport, config = {}) {
        // Create a proxy, wrapping a simple object returning methods that calls functions
        // TODO: Lazily fetch available functions and return these from the ownKeys() trap
        const factory = new FunctionsFactory(transport, config);
        // Wrap the factory in a promise that calls the internal call method
        return new Proxy(factory, {
            get(target, p, receiver) {
                if (typeof p === "string" && RESERVED_NAMES.indexOf(p) === -1) {
                    return target.callFunction.bind(target, p);
                }
                else {
                    return Reflect.get(target, p, receiver);
                }
            },
        });
    }
    /**
     * Call a remote function by it's name.
     *
     * @param name Name of the remote function.
     * @param args Arguments to pass to the remote function.
     * @returns A promise of the value returned when executing the remote function.
     */
    async callFunction(name, ...args) {
        // See https://github.com/mongodb/stitch-js-sdk/blob/master/packages/core/sdk/src/services/internal/CoreStitchServiceClientImpl.ts
        const body = {
            name,
            arguments: this.argsTransformation
                ? this.argsTransformation(args)
                : args,
        };
        if (this.serviceName) {
            body.service = this.serviceName;
        }
        const response = await this.transport.fetch({
            method: "POST",
            path: "/functions/call",
            body,
        });
        // Transform the response, if needed
        if (this.responseTransformation) {
            return this.responseTransformation(response);
        }
        else {
            return response;
        }
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var base64 = createCommonjsModule(function (module, exports) {
(function (global, factory) {
     module.exports = factory(global)
        ;
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal
: commonjsGlobal
), function(global) {
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.6.3";
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa && typeof global.btoa == 'function'
        ? function(b){ return global.btoa(b) } : function(b) {
        if (b.match(/[^\x00-\xFF]/)) throw new RangeError(
            'The string contains invalid characters.'
        );
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(String(u)));
    };
    var mkUriSafe = function (b64) {
        return b64.replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encode = function(u, urisafe) {
        return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
    };
    var encodeURI = function(u) { return encode(u, true) };
    var fromUint8Array;
    if (global.Uint8Array) fromUint8Array = function(a, urisafe) {
        // return btoa(fromCharCode.apply(null, a));
        var b64 = '';
        for (var i = 0, l = a.length; i < l; i += 3) {
            var a0 = a[i], a1 = a[i+1], a2 = a[i+2];
            var ord = a0 << 16 | a1 << 8 | a2;
            b64 +=    b64chars.charAt( ord >>> 18)
                +     b64chars.charAt((ord >>> 12) & 63)
                + ( typeof a1 != 'undefined'
                    ? b64chars.charAt((ord >>>  6) & 63) : '=')
                + ( typeof a2 != 'undefined'
                    ? b64chars.charAt( ord         & 63) : '=');
        }
        return urisafe ? mkUriSafe(b64) : b64;
    };
    // decoder stuff
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob && typeof global.atob == 'function'
        ? function(a){ return global.atob(a) } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = function(a) { return btou(_atob(a)) };
    var _fromURI = function(a) {
        return String(a).replace(/[-_]/g, function(m0) {
            return m0 == '-' ? '+' : '/'
        }).replace(/[^A-Za-z0-9\+\/]/g, '');
    };
    var decode = function(a){
        return _decode(_fromURI(a));
    };
    var toUint8Array;
    if (global.Uint8Array) toUint8Array = function(a) {
        return Uint8Array.from(atob(_fromURI(a)), function(c) {
            return c.charCodeAt(0);
        });
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if ( module.exports) {
        module.exports.Base64 = global.Base64;
    }
    // that's it!
    return {Base64: global.Base64}
}));
});

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Prefixes all request with a path prefix.
 */
class PrefixedTransport {
    /**
     * Constructs a transport that prefix the path of all requests performed.
     *
     * @param transport The underlying transport used to issue requests.
     * @param pathPrefix The path being prefixed onto requests.
     */
    constructor(transport, pathPrefix) {
        this.transport = transport;
        this.pathPrefix = pathPrefix;
    }
    /** @inheritdoc */
    fetch(request) {
        const prefixedRequest = {
            ...request,
            path: `${this.pathPrefix}${request.path || ""}`,
        };
        return this.transport.fetch(prefixedRequest);
    }
    /** @inheritdoc */
    prefix(pathPrefix) {
        return new PrefixedTransport(this, pathPrefix);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * A transport prefixing request paths with the path of the App id and ensuring the correct location is hit.
 */
class AppTransport {
    /**
     * Construct a transport that will prefix the app id to paths and determine location base URL.
     *
     * @param transport The base transport used to issue requests.
     * @param appId The id of the app.
     */
    constructor(transport, appId) {
        this.transport = transport;
        this.appId = appId;
    }
    /** @inheritdoc */
    async fetch(request) {
        const { path, ...restOfRequest } = request;
        return this.transport.fetch({
            ...restOfRequest,
            path: `/app/${this.appId}${path}`,
        });
    }
    /** @inheritdoc */
    prefix(pathPrefix) {
        return new PrefixedTransport(this, pathPrefix);
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * TODO: Determine if the shape of an error response is specific to each service or widely used
 */
class MongoDBRealmError extends Error {
    constructor(method, url, statusCode, statusText, response) {
        if (typeof response === "object" &&
            typeof response.error === "string") {
            const statusSummary = statusText
                ? `status ${statusCode} ${statusText}`
                : `status ${statusCode}`;
            super(`Request failed (${method} ${url}): ${response.error} (${statusSummary})`);
            this.method = method;
            this.url = url;
            this.statusText = statusText;
            this.statusCode = statusCode;
            this.errorCode = response.error_code;
            this.link = response.link;
        }
        else {
            throw new Error("Unexpected error response format");
        }
    }
}

////////////////////////////////////////////////////////////////////////////
const isNodeProcess = typeof process === "object";
class DefaultNetworkTransport {
    constructor() {
        // Determine the fetch implementation
        if (!DefaultNetworkTransport.fetch) {
            // Try to get it from the global
            if (typeof window === "object" &&
                typeof window.fetch === "function") {
                DefaultNetworkTransport.fetch = window.fetch.bind(window);
            }
            else if (isNodeProcess && typeof require === "function") {
                // Making it harder for the static analyzers see this require call
                const nodeRequire = require;
                DefaultNetworkTransport.fetch = nodeRequire("node-fetch");
            }
            else {
                throw new Error("DefaultNetworkTransport.fetch must be set before it's used");
            }
        }
        // Determine the AbortController implementation
        if (!DefaultNetworkTransport.AbortController) {
            if (typeof window === "object" && window.AbortController) {
                DefaultNetworkTransport.AbortController =
                    window.AbortController;
            }
            else if (isNodeProcess && typeof require === "function") {
                // Making it harder for the static analyzers see this require call
                const nodeRequire = require;
                DefaultNetworkTransport.AbortController = nodeRequire("abort-controller");
            }
            else {
                throw new Error("DefaultNetworkTransport.AbortController must be set before it's used");
            }
        }
    }
    fetchAndParse(request) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.fetch(request);
                const contentType = response.headers.get("content-type");
                if (response.ok) {
                    if (contentType === null) {
                        return null;
                    }
                    else if (contentType.startsWith("application/json")) {
                        // Awaiting the response to ensure we'll throw our own error
                        return yield response.json();
                    }
                    else {
                        throw new Error("Expected an empty or a JSON response");
                    }
                }
                else if (contentType &&
                    contentType.startsWith("application/json")) {
                    throw new MongoDBRealmError(request.method, request.url, response.status, response.statusText, yield response.json());
                }
                else {
                    throw new Error(`Unexpected status code (${response.status} ${response.statusText})`);
                }
            }
            catch (err) {
                if (err instanceof MongoDBRealmError) {
                    throw err;
                }
                else {
                    throw new Error(`Request failed (${request.method} ${request.url}): ${err.message}`);
                }
            }
        });
    }
    fetchWithCallbacks(request, handler) {
        // tslint:disable-next-line: no-console
        this.fetch(request)
            .then((response) => __awaiter(this, void 0, void 0, function* () {
            const decodedBody = yield response.text();
            // Pull out the headers of the response
            const responseHeaders = {};
            response.headers.forEach((value, key) => {
                responseHeaders[key] = value;
            });
            return {
                statusCode: response.status,
                headers: responseHeaders,
                body: decodedBody,
            };
        }))
            .then(r => handler.onSuccess(r))
            .catch(e => handler.onError(e));
    }
    fetch(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const { method, url, body, timeoutMs, headers = DefaultNetworkTransport.DEFAULT_HEADERS, } = request;
            const { signal, cancelTimeout } = this.createTimeoutSignal(timeoutMs);
            try {
                // We'll await the response to catch throw our own error
                return yield DefaultNetworkTransport.fetch(url, {
                    method,
                    headers,
                    body: typeof body === "string" ? body : JSON.stringify(body),
                    signal,
                });
            }
            finally {
                // Whatever happens, cancel any timeout
                cancelTimeout();
            }
        });
    }
    createTimeoutSignal(timeoutMs) {
        if (typeof timeoutMs === "number") {
            const controller = new DefaultNetworkTransport.AbortController();
            // Call abort after a specific number of milliseconds
            const timeout = setTimeout(() => {
                controller.abort();
            }, timeoutMs);
            return {
                signal: controller.signal,
                cancelTimeout: () => {
                    clearTimeout(timeout);
                },
            };
        }
        else {
            return {
                signal: undefined,
                cancelTimeout: () => {
                    /* No-op */
                },
            };
        }
    }
}
DefaultNetworkTransport.DEFAULT_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json",
};

////////////////////////////////////////////////////////////////////////////
/**
 * A basic transport, wrapping a NetworkTransport from the "realm-network-transport" package, injecting a baseUrl.
 */
class BaseTransport {
    /**
     * Constructs a base transport, which takes paths (prepended by a base URL) instead of absolute urls.
     *
     * @param networkTransport The underlying network transport.
     * @param baseUrl The base URL to prepend to paths.
     * @param locationContext Optional object used to determine the actual base URL of the app.
     * @param baseRoute Optional base route to prepend to the base URL.
     */
    constructor(networkTransport = new DefaultNetworkTransport(), baseUrl, locationContext, baseRoute = BaseTransport.DEFAULT_BASE_ROUTE) {
        this.networkTransport = networkTransport;
        this.baseUrl = baseUrl;
        this.locationContext = locationContext;
        this.baseRoute = baseRoute;
    }
    /** @inheritdoc */
    async fetch(request) {
        const { path, headers, ignoreLocation = false, ...restOfRequest } = request;
        // Determine the base url
        const baseUrl = await this.determineBaseUrl(ignoreLocation);
        // Execute the request
        return this.networkTransport.fetchAndParse({
            ...restOfRequest,
            url: baseUrl + path,
            headers: { ...BaseTransport.DEFAULT_HEADERS, ...headers },
        });
    }
    /** @inheritdoc */
    prefix(pathPrefix) {
        return new PrefixedTransport(this, pathPrefix);
    }
    /**
     * Determines the base URL from the configuration or from the location context.
     *
     * @param ignoreLocation Ignore the location context.
     */
    async determineBaseUrl(ignoreLocation) {
        if (ignoreLocation || !this.locationContext) {
            return this.baseUrl + this.baseRoute;
        }
        else {
            const location = await this.locationContext.location;
            return location.hostname + this.baseRoute;
        }
    }
}
/**
 * This base route will be prefixed requests issued through by the base transport.
 */
BaseTransport.DEFAULT_BASE_ROUTE = "/api/client/v2.0";
/**
 * Default headers that will always be sat on requests.
 */
BaseTransport.DEFAULT_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json",
};

////////////////////////////////////////////////////////////////////////////
/**
 * Fetches resources as a particular user.
 */
class AuthenticatedTransport {
    /**
     * Constructs a transport that injects authorization headers to requests.
     *
     * @param transport The underlying transport.
     * @param userContext The context controlling what user is authenticated.
     */
    constructor(transport, userContext) {
        this.transport = transport;
        this.userContext = userContext;
    }
    /**
     * Fetch a network resource as an authenticated user.
     *
     * @param request The request to issue towards the server.
     * @param user The user used when fetching, defaults to the `app.currentUser`.
     *             If `null`, the fetch will be unauthenticated.
     * @param retries How many times was this request retried?
     * @returns A response from requesting with authentication.
     */
    async fetch(request, user = this.userContext.currentUser, retries = 0) {
        try {
            const { tokenType = "access", ...rest } = request;
            // Awaiting to intercept errors being thrown
            return await this.transport.fetch({
                ...rest,
                headers: {
                    ...this.buildAuthorizationHeader(user, tokenType),
                    ...request.headers,
                },
            });
        }
        catch (err) {
            if (user &&
                retries === 0 &&
                err instanceof MongoDBRealmError &&
                err.statusCode === 401) {
                // Refresh the access token
                await user.refreshAccessToken();
                // Retry
                return this.fetch(request, user, retries + 1);
            }
            throw err;
        }
    }
    /** @inheritdoc */
    prefix(pathPrefix) {
        const prefixedTransport = this.transport.prefix(pathPrefix);
        return new AuthenticatedTransport(prefixedTransport, this.userContext);
    }
    /**
     * Generate an object with an authorization header to issue requests as a specific user.
     *
     * @param user An optional user to generate the header for.
     * @param tokenType The type of token (access or refresh).
     * @returns An object containing with the users access token as authorization header or undefined if no user is given.
     */
    buildAuthorizationHeader(user, tokenType) {
        if (user && tokenType === "access") {
            return { Authorization: `Bearer ${user.accessToken}` };
        }
        else if (user && tokenType === "refresh") {
            return { Authorization: `Bearer ${user.refreshToken}` };
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * The type of a user.
 */
var UserType;
(function (UserType) {
    /**
     * A normal end-user created this user.
     */
    UserType["Normal"] = "normal";
    /**
     * The user was created by the server.
     */
    UserType["Server"] = "server";
})(UserType || (UserType = {}));
/** @ignore */
var DataKey;
(function (DataKey) {
    /** @ignore */
    DataKey["NAME"] = "name";
    /** @ignore */
    DataKey["EMAIL"] = "email";
    /** @ignore */
    DataKey["PICTURE"] = "picture";
    /** @ignore */
    DataKey["FIRST_NAME"] = "first_name";
    /** @ignore */
    DataKey["LAST_NAME"] = "last_name";
    /** @ignore */
    DataKey["GENDER"] = "gender";
    /** @ignore */
    DataKey["BIRTHDAY"] = "birthday";
    /** @ignore */
    DataKey["MIN_AGE"] = "min_age";
    /** @ignore */
    DataKey["MAX_AGE"] = "max_age";
})(DataKey || (DataKey = {}));
const DATA_MAPPING = {
    [DataKey.NAME]: "name",
    [DataKey.EMAIL]: "email",
    [DataKey.PICTURE]: "pictureUrl",
    [DataKey.FIRST_NAME]: "firstName",
    [DataKey.LAST_NAME]: "lastName",
    [DataKey.GENDER]: "gender",
    [DataKey.BIRTHDAY]: "birthday",
    [DataKey.MIN_AGE]: "minAge",
    [DataKey.MAX_AGE]: "maxAge",
};
/** @inheritdoc */
class UserProfile {
    /**
     * Construct a user profile from the body of a response.
     *
     * @param response The response of a call fetching the users profile.
     */
    constructor(response) {
        /** @inheritdoc */
        this.type = UserType.Normal;
        /** @inheritdoc */
        this.identities = [];
        if (response) {
            if (typeof response.type === "string") {
                this.type = response.type;
            }
            else {
                throw new Error("Expected 'type' in the response body");
            }
            if (Array.isArray(response.identities)) {
                this.identities = response.identities.map((identity) => {
                    return {
                        id: identity.id,
                        providerId: identity["provider_id"],
                        providerType: identity["provider_type"],
                    };
                });
            }
            else {
                throw new Error("Expected 'identities' in the response body");
            }
            const { data } = response;
            if (typeof data === "object") {
                for (const key in DATA_MAPPING) {
                    const value = data[key];
                    const propertyName = DATA_MAPPING[key];
                    if (typeof value === "string" &&
                        propertyName !== "identities" &&
                        propertyName !== "type") {
                        this[propertyName] = value;
                    }
                }
            }
            else {
                throw new Error("Expected 'data' in the response body");
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * A `Storage` which will prefix a key part to every operation.
 */
class PrefixedStorage {
    /**
     * Construct a `Storage` which will prefix a key part to every operation.
     *
     * @param storage The underlying storage to use for operations.
     * @param keyPart The part of the key to prefix when performing operations.
     */
    constructor(storage, keyPart) {
        this.storage = storage;
        this.keyPart = keyPart;
    }
    /** @inheritdoc */
    get(key) {
        return this.storage.get(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);
    }
    /** @inheritdoc */
    set(key, value) {
        return this.storage.set(this.keyPart + PrefixedStorage.PART_SEPARATOR + key, value);
    }
    /** @inheritdoc */
    remove(key) {
        return this.storage.remove(this.keyPart + PrefixedStorage.PART_SEPARATOR + key);
    }
    /** @inheritdoc */
    prefix(keyPart) {
        return new PrefixedStorage(this, keyPart);
    }
    /** @inheritdoc */
    clear(prefix = "") {
        return this.storage.clear(this.keyPart + PrefixedStorage.PART_SEPARATOR + prefix);
    }
    /** @inheritdoc */
    addListener(listener) {
        return this.storage.addListener(listener);
    }
    /** @inheritdoc */
    removeListener(listener) {
        return this.storage.addListener(listener);
    }
}
/**
 * The string separating two parts.
 */
PrefixedStorage.PART_SEPARATOR = ":";

////////////////////////////////////////////////////////////////////////////
/**
 * In-memory storage that will not be persisted.
 */
class LocalStorage {
    /**
     * Constructs a LocalStorage using the global window.
     */
    constructor() {
        if (typeof window === "object") {
            this.window = window;
        }
        else {
            throw new Error("Cannot use LocalStorage without a global window object");
        }
    }
    /** @inheritdoc */
    get(key) {
        return this.window.localStorage.getItem(key);
    }
    /** @inheritdoc */
    set(key, value) {
        return this.window.localStorage.setItem(key, value);
    }
    /** @inheritdoc */
    remove(key) {
        return this.window.localStorage.removeItem(key);
    }
    /** @inheritdoc */
    prefix(keyPart) {
        return new PrefixedStorage(this, keyPart);
    }
    /** @inheritdoc */
    clear(prefix) {
        const keys = [];
        // Iterate all keys to find the once have a matching prefix.
        for (let i = 0; i < this.window.localStorage.length; i++) {
            const key = this.window.localStorage.key(i);
            if (key && (!prefix || key.startsWith(prefix))) {
                keys.push(key);
            }
        }
        // Remove the items in a seperate loop to avoid updating while iterating.
        for (const key of keys) {
            this.window.localStorage.removeItem(key);
        }
    }
    /** @inheritdoc */
    addListener(listener) {
        return this.window.addEventListener("storage", listener);
    }
    /** @inheritdoc */
    removeListener(listener) {
        return this.window.removeEventListener("storage", listener);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * In-memory storage that will not be persisted.
 */
class MemoryStorage {
    constructor() {
        /**
         * Internal state of the storage.
         */
        this.storage = {};
        /**
         * A set of listners.
         */
        this.listeners = new Set();
    }
    /** @inheritdoc */
    get(key) {
        if (key in this.storage) {
            return this.storage[key];
        }
        else {
            return null;
        }
    }
    /** @inheritdoc */
    set(key, value) {
        this.storage[key] = value;
        // Fire the listeners
        this.fireListeners();
    }
    /** @inheritdoc */
    remove(key) {
        delete this.storage[key];
        // Fire the listeners
        this.fireListeners();
    }
    /** @inheritdoc */
    prefix(keyPart) {
        return new PrefixedStorage(this, keyPart);
    }
    /** @inheritdoc */
    clear(prefix) {
        // Iterate all keys and delete their values if they have a matching prefix
        for (const key of Object.keys(this.storage)) {
            if (!prefix || key.startsWith(prefix)) {
                delete this.storage[key];
            }
        }
        // Fire the listeners
        this.fireListeners();
    }
    /** @inheritdoc */
    addListener(listener) {
        return this.listeners.add(listener);
    }
    /** @inheritdoc */
    removeListener(listener) {
        return this.listeners.delete(listener);
    }
    /**
     * Tell the listeners that a change occurred.
     */
    fireListeners() {
        this.listeners.forEach(listener => listener());
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * We're reusing a singleton to simulate the persistance of the browsers `localStorage`.
 */
const memoryStorageSingleton = new MemoryStorage();
/**
 * Create a `Storage` instance, default to the current environment.
 *
 * @returns A LocalStorage instance if the window global is an object, MemoryStorage otherwise.
 *          Both will prefix keys with "realm-web".
 */
function createDefaultStorage() {
    const storage = typeof window === "object"
        ? new LocalStorage()
        : memoryStorageSingleton;
    return storage.prefix("realm-web");
}

////////////////////////////////////////////////////////////////////////////
const ACCESS_TOKEN_STORAGE_KEY = "accessToken";
const REFRESH_TOKEN_STORAGE_KEY = "refreshToken";
const PROFILE_STORAGE_KEY = "profile";
/**
 * Storage specific to the app.
 */
class UserStorage extends PrefixedStorage {
    /**
     * Construct a storage for a `User`.
     *
     * @param storage The underlying storage to wrap.
     * @param userId The id of the user.
     */
    constructor(storage, userId) {
        super(storage, `user(${userId})`);
    }
    /**
     * Get the access token from storage.
     *
     * @returns Access token (null if unknown).
     */
    get accessToken() {
        return this.get(ACCESS_TOKEN_STORAGE_KEY);
    }
    /**
     * Set the access token in storage.
     *
     * @param value Access token (null if unknown).
     */
    set accessToken(value) {
        if (value === null) {
            this.remove(ACCESS_TOKEN_STORAGE_KEY);
        }
        else {
            this.set(ACCESS_TOKEN_STORAGE_KEY, value);
        }
    }
    /**
     * Get the refresh token from storage.
     *
     * @returns Refresh token (null if unknown and user is logged out).
     */
    get refreshToken() {
        return this.get(REFRESH_TOKEN_STORAGE_KEY);
    }
    /**
     * Set the refresh token in storage.
     *
     * @param value Refresh token (null if unknown and user is logged out).
     */
    set refreshToken(value) {
        if (value === null) {
            this.remove(REFRESH_TOKEN_STORAGE_KEY);
        }
        else {
            this.set(REFRESH_TOKEN_STORAGE_KEY, value);
        }
    }
    /**
     * Get the user profile from storage.
     *
     * @returns User profile (undefined if its unknown).
     */
    get profile() {
        const value = this.get(PROFILE_STORAGE_KEY);
        if (value) {
            const profile = new UserProfile();
            // Patch in the values
            Object.assign(profile, JSON.parse(value));
            return profile;
        }
    }
    /**
     * Set the user profile in storage.
     *
     * @param value User profile (undefined if its unknown).
     */
    set profile(value) {
        if (!value) {
            this.remove(PROFILE_STORAGE_KEY);
        }
        else {
            this.set(PROFILE_STORAGE_KEY, JSON.stringify(value));
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/** @inheritdoc */
class EmailPasswordAuth {
    /**
     * Construct an interface to the email / password authentication provider.
     *
     * @param transport The underlying transport used to request the services.
     * @param providerName Optional custom name of the authentication provider.
     */
    constructor(transport, providerName = "local-userpass") {
        this.transport = transport.prefix(`/auth/providers/${providerName}`);
    }
    /** @inheritdoc */
    registerUser(email, password) {
        return this.transport.fetch({
            method: "POST",
            path: "/register",
            body: { email, password },
        });
    }
    /** @inheritdoc */
    confirmUser(token, tokenId) {
        return this.transport.fetch({
            method: "POST",
            path: "/confirm",
            body: { token, tokenId },
        });
    }
    /** @inheritdoc */
    resendConfirmationEmail(email) {
        return this.transport.fetch({
            method: "POST",
            path: "/confirm/send",
            body: { email },
        });
    }
    /** @inheritdoc */
    resetPassword(token, tokenId, password) {
        return this.transport.fetch({
            method: "POST",
            path: "/reset",
            body: { token, tokenId, password },
        });
    }
    /** @inheritdoc */
    sendResetPasswordEmail(email) {
        return this.transport.fetch({
            method: "POST",
            path: "/reset/send",
            body: { email },
        });
    }
    /** @inheritdoc */
    callResetPasswordFunction(email, password, args) {
        return this.transport.fetch({
            method: "POST",
            path: "/reset/call",
            body: { email, password, arguments: args },
        });
    }
}

////////////////////////////////////////////////////////////////////////////
/** @inheritdoc */
class ApiKeyAuth {
    /**
     * Construct an interface to the API-key authentication provider.
     *
     * @param transport The transport used to send requests to services.
     * @param providerName Optional custom name of the authentication provider.
     */
    constructor(transport, providerName = "api-key") {
        this.transport = transport.prefix("/auth/api_keys");
    }
    /** @inheritdoc */
    create(name) {
        return this.transport
            .fetch({
            method: "POST",
            body: { name },
            tokenType: "refresh",
        })
            .then(deserialize);
    }
    /** @inheritdoc */
    fetch(keyId) {
        return this.transport
            .fetch({
            method: "GET",
            path: `/${keyId}`,
            tokenType: "refresh",
        })
            .then(deserialize);
    }
    /** @inheritdoc */
    fetchAll() {
        return this.transport
            .fetch({ method: "GET", tokenType: "refresh" })
            .then(deserialize);
    }
    /** @inheritdoc */
    delete(keyId) {
        return this.transport
            .fetch({
            method: "DELETE",
            path: `/${keyId}`,
            tokenType: "refresh",
        })
            .then(deserialize);
    }
    /** @inheritdoc */
    enable(keyId) {
        return this.transport
            .fetch({
            method: "PUT",
            path: `/${keyId}/enable`,
            tokenType: "refresh",
        })
            .then(deserialize);
    }
    /** @inheritdoc */
    disable(keyId) {
        return this.transport
            .fetch({
            method: "PUT",
            path: `/${keyId}/disable`,
            tokenType: "refresh",
        })
            .then(deserialize);
    }
}

////////////////////////////////////////////////////////////////////////////
var UserState;
(function (UserState) {
    UserState["Active"] = "active";
    UserState["LoggedOut"] = "logged-out";
    UserState["Removed"] = "removed";
})(UserState || (UserState = {}));
var UserType$1;
(function (UserType) {
    UserType["Normal"] = "normal";
    UserType["Server"] = "server";
})(UserType$1 || (UserType$1 = {}));
async function performLogIn(app, credentials) {
    // See https://github.com/mongodb/stitch-js-sdk/blob/310f0bd5af80f818cdfbc3caf1ae29ffa8e9c7cf/packages/core/sdk/src/auth/internal/CoreStitchAuth.ts#L746-L780
    const response = await app.appTransport.fetch({
        method: "POST",
        path: `/auth/providers/${credentials.providerName}/login`,
        body: credentials.payload,
    });
    // Spread out values from the response and ensure they're valid
    const { user_id: id, access_token: accessToken, refresh_token: refreshToken, } = response;
    if (typeof id !== "string") {
        throw new Error("Expected a user id in the response");
    }
    if (typeof accessToken !== "string") {
        throw new Error("Expected an access token in the response");
    }
    if (typeof refreshToken !== "string") {
        throw new Error("Expected a refresh token in the response");
    }
    return { id, accessToken, refreshToken };
}
/**
 * Representation of an authenticated user of an app.
 */
class User {
    constructor({ app, id, accessToken, refreshToken }) {
        this.app = app;
        this._id = id;
        this._accessToken = accessToken;
        this._refreshToken = refreshToken;
        this.transport = new AuthenticatedTransport(app.baseTransport, {
            currentUser: this,
        });
        const appTransport = new AppTransport(this.transport, app.id);
        this.apiKeys = new ApiKeyAuth(this.transport);
        this.functions = FunctionsFactory.create(appTransport);
        this.storage = new UserStorage(app.storage, id);
        // Store tokens in storage for later hydration
        if (accessToken) {
            this.storage.accessToken = accessToken;
        }
        if (refreshToken) {
            this.storage.refreshToken = refreshToken;
        }
    }
    /**
     * Creates a user from the data stored in the storage of an `App` instance.
     *
     * @param app The app that the user was logged into.
     * @param userId The id of the user to restore.
     * @returns The user created from values retrieved from storage.
     */
    static hydrate(app, userId) {
        const user = new User({
            app,
            id: userId,
            accessToken: null,
            refreshToken: null,
        });
        user.hydrate();
        return user;
    }
    /**
     * The automatically-generated internal id of the user.
     *
     * @returns The id of the user in the MongoDB Realm database.
     */
    get id() {
        return this._id;
    }
    /**
     * @returns The access token used to authenticate the user towards MongoDB Realm.
     */
    get accessToken() {
        return this._accessToken;
    }
    /**
     * @param token The new access token.
     */
    set accessToken(token) {
        this._accessToken = token;
        this.storage.accessToken = token;
    }
    /**
     * @returns The refresh token used to issue new access tokens.
     */
    get refreshToken() {
        return this._refreshToken;
    }
    /**
     * @param token The new refresh token.
     */
    set refreshToken(token) {
        this._refreshToken = token;
        this.storage.refreshToken = token;
    }
    /**
     * The state of the user is one of:
     * - "active" The user is logged in and ready.
     * - "logged-out" The user was logged in, but is no longer logged in.
     * - "removed" The user was logged in, but removed entirely from the app again.
     *
     * @returns The current state of the user.
     */
    get state() {
        if (this.app.allUsers.indexOf(this) === -1) {
            return UserState.Removed;
        }
        else {
            return this.refreshToken === null
                ? UserState.LoggedOut
                : UserState.Active;
        }
    }
    get customData() {
        if (this.accessToken) {
            const decodedToken = this.decodeAccessToken();
            return decodedToken.userData;
        }
        else {
            throw new Error("Cannot read custom data without an access token");
        }
    }
    /**
     * @returns Profile containing detailed information about the user.
     */
    get profile() {
        if (this._profile) {
            return this._profile;
        }
        else {
            throw new Error("A profile was never fetched for this user");
        }
    }
    async refreshProfile() {
        // Fetch the latest profile
        const response = await this.transport.fetch({
            method: "GET",
            path: "/auth/profile",
        });
        // Create a profile instance
        this._profile = new UserProfile(response);
        // Store this for later hydration
        this.storage.profile = this._profile;
    }
    async logOut() {
        // Invalidate the refresh token
        if (this._refreshToken !== null) {
            await this.app.baseTransport.fetch({
                method: "DELETE",
                path: "/auth/session",
                headers: {
                    Authorization: `Bearer ${this._refreshToken}`,
                },
            });
        }
        // Forget the access and refresh token
        this.accessToken = null;
        this.refreshToken = null;
    }
    /**
     * Authenticate and retrieve the access and refresh tokens.
     *
     * @param credentials Credentials to use when logging in.
     */
    async logIn(credentials) {
        const { id, accessToken, refreshToken } = await performLogIn(this.app, credentials);
        if (id !== this.id) {
            throw new Error("Logged into a different user");
        }
        // Store the access and refresh token
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
    }
    /** @inheritdoc */
    async linkCredentials(credentials) {
        throw new Error("Not yet implemented");
    }
    async refreshAccessToken() {
        const response = await this.app.baseTransport.fetch({
            method: "POST",
            path: "/auth/session",
            headers: {
                Authorization: `Bearer ${this.refreshToken}`,
            },
        });
        const { access_token: accessToken } = response;
        if (typeof accessToken === "string") {
            this.accessToken = accessToken;
        }
        else {
            throw new Error("Expected an 'access_token' in the response");
        }
    }
    async refreshCustomData() {
        await this.refreshAccessToken();
        return this.customData;
    }
    callFunction(name, ...args) {
        return this.functions.callFunction(name, ...args);
    }
    /**
     * Restore a user from the data stored in the storage of an `App` instance.
     */
    hydrate() {
        // Hydrate tokens
        const accessToken = this.storage.accessToken;
        const refreshToken = this.storage.refreshToken;
        const profile = this.storage.profile;
        if (typeof accessToken === "string") {
            this.accessToken = accessToken;
        }
        if (typeof refreshToken === "string") {
            this.refreshToken = refreshToken;
        }
        if (typeof profile === "object") {
            this._profile = profile;
        }
    }
    push(serviceName = "") {
        throw new Error("Not yet implemented");
    }
    decodeAccessToken() {
        if (this.accessToken) {
            // Decode and spread the token
            const parts = this.accessToken.split(".");
            if (parts.length !== 3) {
                throw new Error("Expected three parts");
            }
            // Decode the payload
            const encodedPayload = parts[1];
            const decodedPayload = base64.Base64.decode(encodedPayload);
            const parsedPayload = JSON.parse(decodedPayload);
            const { exp: expires, iat: issuedAt, user_data: userData = {}, } = parsedPayload;
            // Validate the types
            if (typeof expires !== "number") {
                throw new Error("Failed to decode access token 'exp'");
            }
            else if (typeof issuedAt !== "number") {
                throw new Error("Failed to decode access token 'iat'");
            }
            return { expires, issuedAt, userData };
        }
        else {
            throw new Error("Missing an access token");
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Instances of this class can be passed to the `app.logIn` method to authenticate an end-user.
 */
class Credentials {
    /**
     * Constructs an instance of credentials.
     *
     * @param providerName The name of the authentication provider used when authenticating.
     * @param providerType The type of the authentication provider used when authenticating.
     * @param payload The data being sent to the service when authenticating.
     */
    constructor(providerName, providerType, payload) {
        this.providerName = providerName;
        this.providerType = providerType;
        this.payload = payload;
    }
    /**
     * Creates credentials that logs in using the [Anonymous Provider](https://docs.mongodb.com/realm/authentication/anonymous/).
     *
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static anonymous() {
        return new Credentials("anon-user", "anon-user", {});
    }
    /**
     * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).
     *
     * @deprecated Use `Credentials.apiKey`.
     *
     * @param key The secret content of the API key.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static userApiKey(key) {
        return new Credentials("api-key", "api-key", { key });
    }
    /**
     * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).
     *
     * @deprecated Use `Credentials.apiKey`.
     *
     * @param key The secret content of the API key.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static serverApiKey(key) {
        return new Credentials("api-key", "api-key", { key });
    }
    /**
     * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).
     *
     * @param key The secret content of the API key.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static apiKey(key) {
        return new Credentials("api-key", "api-key", { key });
    }
    /**
     * Creates credentials that logs in using the [Email/Password Provider](https://docs.mongodb.com/realm/authentication/email-password/).
     * Note: This was formerly known as the "Username/Password" provider.
     *
     * @param email The end-users email address.
     * @param password The end-users password.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static emailPassword(email, password) {
        return new Credentials("local-userpass", "local-userpass", {
            username: email,
            password,
        });
    }
    /**
     * Creates credentials that logs in using the [Custom Function Provider](https://docs.mongodb.com/realm/authentication/custom-function/).
     *
     * @param payload The custom payload as expected by the server.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static function(payload) {
        return new Credentials("custom-function", "custom-function", payload);
    }
    /**
     * Creates credentials that logs in using the [Custom JWT Provider](https://docs.mongodb.com/realm/authentication/custom-jwt/).
     *
     * @param token The JSON Web Token (JWT).
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static jwt(token) {
        return new Credentials("custom-token", "custom-token", {
            token,
        });
    }
    /**
     * Creates credentials that logs in using the [Google Provider](https://docs.mongodb.com/realm/authentication/google/).
     *
     * @param redirectUrlOrAuthCode The URL that users should be redirected to or the auth code returned from Google.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static google(redirectUrlOrAuthCode) {
        return new Credentials("oauth2-google", "oauth2-google", redirectUrlOrAuthCode.indexOf("://") !== -1
            ? { redirectUrl: redirectUrlOrAuthCode }
            : { authCode: redirectUrlOrAuthCode });
    }
    /**
     * Creates credentials that logs in using the [Facebook Provider](https://docs.mongodb.com/realm/authentication/facebook/).
     *
     * @param redirectUrlOrAccessToken The URL that users should be redirected to or the auth code returned from Facebook.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static facebook(redirectUrlOrAccessToken) {
        return new Credentials("oauth2-facebook", "oauth2-facebook", redirectUrlOrAccessToken.indexOf("://") !== -1
            ? { redirectUrl: redirectUrlOrAccessToken }
            : { accessToken: redirectUrlOrAccessToken });
    }
    /**
     * Creates credentials that logs in using the [Apple ID Provider](https://docs.mongodb.com/realm/authentication/apple/).
     *
     * @param redirectUrlOrIdToken The URL that users should be redirected to or the id_token returned from Apple.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static apple(redirectUrlOrIdToken) {
        return new Credentials("oauth2-apple", "oauth2-apple", redirectUrlOrIdToken.indexOf("://") !== -1
            ? { redirectUrl: redirectUrlOrIdToken }
            : {
                // eslint-disable-next-line @typescript-eslint/camelcase
                id_token: redirectUrlOrIdToken,
            });
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * A remote collection of documents.
 */
class MongoDBCollection {
    /**
     * Construct a remote collection of documents.
     *
     * @param transport The transport to use when requesting the service.
     * @param serviceName The name of the remote service.
     * @param databaseName The name of the database.
     * @param collectionName The name of the remote collection.
     */
    constructor(transport, serviceName, databaseName, collectionName) {
        this.functions = FunctionsFactory.create(transport, {
            serviceName,
        });
        this.databaseName = databaseName;
        this.collectionName = collectionName;
    }
    /** @inheritdoc */
    find(filter = {}, options = {}) {
        return this.functions.find({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
            project: options.projection,
            sort: options.sort,
            limit: options.limit,
        });
    }
    /** @inheritdoc */
    findOne(filter = {}, options = {}) {
        return this.functions.findOne({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
            project: options.projection,
            sort: options.sort,
        });
    }
    /** @inheritdoc */
    findOneAndUpdate(filter = {}, update, options = {}) {
        return this.functions.findOneAndUpdate({
            database: this.databaseName,
            collection: this.collectionName,
            filter,
            update,
            sort: options.sort,
            projection: options.projection,
            upsert: options.upsert,
            returnNewDocument: options.returnNewDocument,
        });
    }
    /** @inheritdoc */
    findOneAndReplace(filter = {}, replacement, options = {}) {
        return this.functions.findOneAndReplace({
            database: this.databaseName,
            collection: this.collectionName,
            filter: filter,
            update: replacement,
            sort: options.sort,
            projection: options.projection,
            upsert: options.upsert,
            returnNewDocument: options.returnNewDocument,
        });
    }
    /** @inheritdoc */
    findOneAndDelete(filter = {}, options = {}) {
        return this.functions.findOneAndReplace({
            database: this.databaseName,
            collection: this.collectionName,
            filter,
            sort: options.sort,
            projection: options.projection,
        });
    }
    /** @inheritdoc */
    aggregate(pipeline) {
        return this.functions.aggregate({
            database: this.databaseName,
            collection: this.collectionName,
            pipeline,
        });
    }
    /** @inheritdoc */
    count(filter = {}, options = {}) {
        return this.functions.count({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
            limit: options.limit,
        });
    }
    /** @inheritdoc */
    insertOne(document) {
        return this.functions.insertOne({
            database: this.databaseName,
            collection: this.collectionName,
            document,
        });
    }
    /** @inheritdoc */
    insertMany(documents) {
        return this.functions.insertMany({
            database: this.databaseName,
            collection: this.collectionName,
            documents,
        });
    }
    /** @inheritdoc */
    deleteOne(filter = {}) {
        return this.functions.deleteOne({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
        });
    }
    /** @inheritdoc */
    deleteMany(filter = {}) {
        return this.functions.deleteMany({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
        });
    }
    /** @inheritdoc */
    updateOne(filter, update, options = {}) {
        return this.functions.updateOne({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
            update,
            upsert: options.upsert,
        });
    }
    /** @inheritdoc */
    updateMany(filter, update, options = {}) {
        return this.functions.updateMany({
            database: this.databaseName,
            collection: this.collectionName,
            query: filter,
            update,
            upsert: options.upsert,
        });
    }
}
/**
 * Creates an Remote MongoDB Collection.
 * Note: This method exists to enable function binding.
 *
 * @param transport The underlying transport.
 * @param serviceName A service name.
 * @param databaseName A database name.
 * @param collectionName A collection name.
 * @returns The collection.
 */
function createCollection(transport, serviceName, databaseName, collectionName) {
    return new MongoDBCollection(transport, serviceName, databaseName, collectionName);
}
/**
 * Creates a Remote MongoDB Database.
 * Note: This method exists to enable function binding.
 *
 * @param transport The underlying transport
 * @param serviceName A service name
 * @param databaseName A database name
 * @returns The database.
 */
function createDatabase(transport, serviceName, databaseName) {
    return {
        collection: createCollection.bind(null, transport, serviceName, databaseName),
    };
}
/**
 * Creates a Remote MongoDB Service.
 * Note: This method exists to enable function binding.
 *
 * @param transport The underlying transport.
 * @param serviceName An optional service name.
 * @returns The service.
 */
function createService(transport, serviceName = "mongo-db") {
    return { db: createDatabase.bind(null, transport, serviceName) };
}

////////////////////////////////////////////////////////////////////////////
// @see https://github.com/mongodb/stitch-js-sdk/blob/master/packages/core/services/http/src/internal/CoreHttpServiceClient.ts
/**
 * The Stitch HTTP Service is a generic interface that enables you to communicate with any service that is available over HTTP.
 *
 * @see https://docs.mongodb.com/stitch/services/http/
 */
class HTTPService {
    /**
     * Construct an HTTP Service.
     *
     * @param transport The underlying transport.
     * @param serviceName An optional service name.
     */
    constructor(transport, serviceName = "http") {
        this.functions = FunctionsFactory.create(transport, {
            serviceName,
        });
    }
    /**
     * Sends an HTTP GET request to the specified URL.
     *
     * @param url The URL to send the request to.
     * @param options Options related to the request.
     * @returns The response.
     */
    get(url, options = {}) {
        return this.functions.get({ url, ...options });
    }
    /**
     * Sends an HTTP POST request to the specified URL.
     *
     * @param url The URL to send the request to.
     * @param options Options related to the request.
     * @returns The response.
     */
    post(url, options = {}) {
        return this.functions.post({ url, ...options });
    }
    /**
     * Sends an HTTP PUT request to the specified URL.
     *
     * @param url The URL to send the request to.
     * @param options Options related to the request.
     * @returns The response.
     */
    put(url, options = {}) {
        return this.functions.put({ url, ...options });
    }
    /**
     * Sends an HTTP DELETE request to the specified URL.
     *
     * @param url The URL to send the request to.
     * @param options Options related to the request.
     * @returns The response.
     */
    delete(url, options = {}) {
        return this.functions.delete({ url, ...options });
    }
    /**
     * Sends an HTTP HEAD request to the specified URL.
     *
     * @param url The URL to send the request to.
     * @param options Options related to the request.
     * @returns The response.
     */
    head(url, options = {}) {
        return this.functions.head({ url, ...options });
    }
    /**
     * Sends an HTTP PATCH request to the specified URL.
     *
     * @param url The URL to send the request to.
     * @param options Options related to the request.
     * @returns The response.
     */
    patch(url, options = {}) {
        return this.functions.patch({ url, ...options });
    }
}
/**
 * Creates an HTTP Service.
 * Note: This method exists to enable function binding.
 *
 * @param transport The underlying transport.
 * @param serviceName An optional service name.
 * @returns The new HTTP Service.
 */
function createService$1(transport, serviceName = "http") {
    return new HTTPService(transport, serviceName);
}

////////////////////////////////////////////////////////////////////////////
/**
 * Create all services for a particular app.
 *
 * @param transport The transport to use when senting requests to the services.
 * @returns An object containing functions that create the individual services.
 */
function create(transport) {
    return {
        mongodb: createService.bind(null, transport),
        http: createService$1.bind(null, transport),
    };
}

////////////////////////////////////////////////////////////////////////////
const USER_IDS_STORAGE_KEY = "userIds";
/**
 * Storage specific to the app.
 */
class AppStorage extends PrefixedStorage {
    /**
     * Construct a storage for an `App`
     *
     * @param storage The underlying storage to wrap.
     * @param appId The id of the app.
     */
    constructor(storage, appId) {
        super(storage, `app(${appId})`);
    }
    /**
     * Reads out the list of user ids from storage.
     *
     * @returns A list of user ids.
     */
    getUserIds() {
        try {
            const userIdsString = this.get(USER_IDS_STORAGE_KEY);
            const userIds = userIdsString ? JSON.parse(userIdsString) : [];
            if (Array.isArray(userIds)) {
                // Remove any duplicates that might have been added
                // The Set preserves insertion order
                return [...new Set(userIds)];
            }
            else {
                throw new Error("Expected an array");
            }
        }
        catch (err) {
            // The storage was corrupted
            this.remove(USER_IDS_STORAGE_KEY);
            throw err;
        }
    }
    /**
     * Sets the list of ids in storage.
     * Optionally merging with existing ids stored in the storage, by prepending these while voiding duplicates.
     *
     * @param userIds The list of ids to store.
     * @param mergeWithExisting Prepend existing ids to avoid data-races with other apps using this storage.
     */
    setUserIds(userIds, mergeWithExisting) {
        if (mergeWithExisting) {
            // Add any existing user id to the end of this list, avoiding duplicates
            const existingIds = this.getUserIds();
            for (const id of existingIds) {
                if (userIds.indexOf(id) === -1) {
                    userIds.push(id);
                }
            }
        }
        // Store the list of ids
        this.set(USER_IDS_STORAGE_KEY, JSON.stringify(userIds));
    }
    /**
     * Remove an id from the list of ids.
     *
     * @param userId The id of a User to be removed.
     */
    removeUserId(userId) {
        const existingIds = this.getUserIds();
        const userIds = existingIds.filter(id => id !== userId);
        // Store the list of ids
        this.setUserIds(userIds, false);
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Generate a random sequence of characters.
 *
 * @param length The length of the string.
 * @param alphabet The alphabet of characters to pick from.
 * @returns A string of characters picked randomly from `alphabet`.
 */
function generateRandomString(length, alphabet) {
    let result = "";
    for (let i = 0; i < length; i++) {
        result += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    return result;
}
/**
 * Encode an object mapping from string to string, into a query string to be appended a URL.
 *
 * @param params The parameters to include in the string.
 * @returns A URL encoded representation of the parameters.
 */
function encodeQueryString(params) {
    return Object.entries(params)
        .map(([k, v]) => [k, encodeURIComponent(v)])
        .map(([k, v]) => `${k}=${v}`)
        .join("&");
}
/**
 * Decodes a query string into an object.
 *
 * @param str The query string to decode.
 * @returns The decoded query string.
 */
function decodeQueryString(str) {
    return Object.fromEntries(str
        .split("&")
        .map(kvp => kvp.split("="))
        .map(([k, v]) => [k, decodeURIComponent(v)]));
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2020 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const LOWERCASE_LETTERS = "abcdefghijklmnopqrstuvwxyz";
const defaultOpenWindow = url => {
    if (typeof window === "object") {
        return window.open(url);
    }
    else {
        console.log(`Please open this URL: ${url}`);
        return null;
    }
};
/* eslint-disable @typescript-eslint/camelcase */
const REDIRECT_HASH_TO_RESULT = {
    _stitch_client_app_id: "appId",
    _baas_client_app_id: "appId",
    _stitch_ua: "userAuth",
    _baas_ua: "userAuth",
    _stitch_link: "link",
    _baas_link: "link",
    _stitch_error: "error",
    _baas_error: "error",
    _stitch_state: "state",
    _baas_state: "state",
};
/* eslint-enable @typescript-eslint/camelcase */
/**
 * A collection of methods helping implement the OAuth2 flow.
 */
class OAuth2Helper {
    /**
     * Construct a helper implementing the OAuth2 flow.
     *
     * @param storage The underlying storage to use when storing and retriving secrets.
     * @param getAppUrl Call this to determine the app url.
     * @param openWindow An optional function called when a browser window needs to open.
     */
    constructor(storage, getAppUrl, openWindow = defaultOpenWindow) {
        this.storage = storage.prefix("oauth2");
        this.getAppUrl = getAppUrl;
        this.openWindow = openWindow;
    }
    /**
     * Parses the query string from the final step of the OAuth flow.
     *
     * @param queryString The query string passed through in location.hash.
     * @returns The result of the OAuth flow.
     */
    static parseRedirectLocation(queryString) {
        const params = decodeQueryString(queryString);
        const result = {};
        for (const [p, r] of Object.entries(REDIRECT_HASH_TO_RESULT)) {
            const value = params[p];
            if (value) {
                result[r] = value;
            }
        }
        return result;
    }
    /**
     * Handle the redirect querystring by parsing it and storing it for others to consume.
     *
     * @param queryString The query string containing the encoded result from the OAuth provider.
     * @param storage The underlying storage used to persist the result.
     */
    static handleRedirect(queryString, storage = createDefaultStorage()) {
        const helper = new OAuth2Helper(storage, async () => {
            throw new Error("This instance cannot be used to initiate a flow");
        });
        const result = OAuth2Helper.parseRedirectLocation(queryString);
        helper.handleRedirect(result);
    }
    /**
     * Decodes the authInfo string into its seperate parts.
     *
     * @param authInfo An authInfo string returned from the server.
     * @returns An object containing the separate parts of the authInfo string.
     */
    static decodeAuthInfo(authInfo) {
        const parts = (authInfo || "").split("$");
        if (parts.length === 4) {
            const [accessToken, refreshToken, userId, deviceId] = parts;
            return { accessToken, refreshToken, userId, deviceId };
        }
        else {
            throw new Error("Failed to decode 'authInfo' into ids and tokens");
        }
    }
    /**
     * Initiates the flow by opening a browser window.
     *
     * @param credentials A set of OAuth2 credentials with a redirectUrl in its payload.
     * @returns The secret.
     */
    async initiate(credentials) {
        // TODO: Implement a timeout and an option to cancel.
        const state = this.generateState();
        const stateStorage = this.getStateStorage(state);
        const url = await this.generateOAuth2Url(credentials, state);
        // Return a promise that resolves when the  gets known
        return new Promise(resolve => {
            let redirectWindow = null;
            const handleStorageUpdate = () => {
                // Trying to get the secret from storage
                const result = stateStorage.get("result");
                if (result) {
                    const parsedResult = JSON.parse(result);
                    // The secret got updated!
                    stateStorage.removeListener(handleStorageUpdate);
                    // Clear the storage to prevent others from reading this
                    stateStorage.clear();
                    // Try closing the newly created window
                    try {
                        if (redirectWindow) {
                            redirectWindow.close();
                        }
                    }
                    catch (err) {
                        console.warn(`Failed closing redirect window: ${err}`);
                    }
                    finally {
                        resolve(parsedResult);
                    }
                }
            };
            // Add a listener to the state storage, awaiting an update to the secret
            stateStorage.addListener(handleStorageUpdate);
            // Open up a window
            redirectWindow = this.openWindow(url);
        });
    }
    /**
     * Generate the URL to which the user should be redirected to initiate the OAuth2 flow.
     *
     * @param credentials A set of OAuth2 credentials with a redirectUrl in its payload.
     * @param state A random state, used to track the request throughout the flow, avoiding CSRF attacks.
     * @returns A URL to redirect the user to.
     */
    async generateOAuth2Url(credentials, state) {
        const { redirectUrl } = credentials.payload;
        const appUrl = await this.getAppUrl();
        const qs = encodeQueryString({
            redirect: redirectUrl,
            state,
        });
        return `${appUrl}/auth/providers/${credentials.providerName}/login?${qs}`;
    }
    /**
     * Handle a redirect.
     *
     * @param result The result from parsing the OAuth 2.0 redirect URL.
     */
    handleRedirect(result) {
        const { state, error } = result;
        if (typeof state === "string") {
            const storage = this.getStateStorage(state);
            storage.set("result", JSON.stringify(result));
        }
        else if (error) {
            throw new Error(`Failed to handle OAuth 2.0 redirect: ${error}`);
        }
        else {
            throw new Error("Failed to handle OAuth 2.0 redirect.");
        }
    }
    /**
     * Generate a random state string.
     *
     * @returns The random state string.
     */
    generateState() {
        return generateRandomString(12, LOWERCASE_LETTERS);
    }
    /**
     * Get the storage key associated of an secret associated with a state.
     *
     * @param state The random state.
     * @returns The storage associated with a particular state.
     */
    getStateStorage(state) {
        return this.storage.prefix(`state(${state})`);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * MongoDB Realm App
 */
class App {
    /**
     * Construct a Realm App, either from the Realm App id visible from the MongoDB Realm UI or a configuration.
     *
     * @param idOrConfiguration The Realm App id or a configuration to use for this app.
     */
    constructor(idOrConfiguration) {
        /**
         * An array of active and logged-out users.
         * Elements in the beginning of the array is considered more recent than the later elements.
         */
        this.users = [];
        // If the argument is a string, convert it to a simple configuration object.
        const configuration = typeof idOrConfiguration === "string"
            ? { id: idOrConfiguration }
            : idOrConfiguration;
        // Initialize properties from the configuration
        if (typeof configuration === "object" &&
            typeof configuration.id === "string") {
            this.id = configuration.id;
        }
        else {
            throw new Error("Missing a MongoDB Realm app-id");
        }
        const { transport, storage, baseUrl, fetchLocation = true, } = configuration;
        // Construct the various transports
        this.baseTransport = new BaseTransport(transport, baseUrl || App.DEFAULT_BASE_URL, fetchLocation ? this : undefined);
        this.appTransport = this.baseTransport.prefix(`/app/${this.id}`);
        const authTransport = new AuthenticatedTransport(this.appTransport, this);
        // Construct the functions factory
        this.functions = FunctionsFactory.create(authTransport);
        // Construct the services factory
        this.services = create(authTransport);
        // Construct the auth providers
        this.emailPasswordAuth = new EmailPasswordAuth(authTransport);
        // Construct the storage
        const baseStorage = storage || createDefaultStorage();
        this.storage = new AppStorage(baseStorage, this.id);
        // Constructing the oauth2 helper, passing in the baseStorage to avoid an app scope.
        this.oauth2 = new OAuth2Helper(baseStorage, async () => {
            const baseUrl = await this.baseTransport.determineBaseUrl(false);
            return `${baseUrl}/app/${this.id}`;
        });
        // Hydrate the app state from storage
        this.hydrate();
    }
    /**
     * Switch user
     *
     * @param nextUser The user or id of the user to switch to
     */
    switchUser(nextUser) {
        const index = this.users.findIndex(u => u === nextUser);
        if (index === -1) {
            throw new Error("The user was never logged into this app");
        }
        // Remove the user from the stack
        const [user] = this.users.splice(index, 1);
        // Insert the user in the beginning of the stack
        this.users.unshift(user);
    }
    /**
     * Log in a user
     *
     * @param credentials Credentials to use when logging in
     * @param fetchProfile Should the users profile be fetched? (default: true)
     */
    async logIn(credentials, fetchProfile = true) {
        const user = await this.performLogIn(credentials);
        // Let's ensure this will be the current user, in case the user object was reused.
        this.switchUser(user);
        // If neeeded, fetch and set the profile on the user
        if (fetchProfile) {
            await user.refreshProfile();
        }
        // Persist the user id in the storage,
        // merging to avoid overriding logins from other apps using the same underlying storage
        this.storage.setUserIds(this.users.map(u => u.id), true);
        // Return the user
        return user;
    }
    /**
     * @inheritdoc
     */
    async removeUser(user) {
        // Remove the user from the list of users
        const index = this.users.findIndex(u => u === user);
        if (index === -1) {
            throw new Error("The user was never logged into this app");
        }
        this.users.splice(index, 1);
        // Log out the user - this removes access and refresh tokens from storage
        await user.logOut();
        // Remove the users profile from storage
        this.storage.remove(`user(${user.id}):profile`);
        // Remove the user from the storage
        this.storage.removeUserId(user.id);
    }
    /**
     * The currently active user (or null if no active users exists)
     *
     * @returns the currently active user or null.
     */
    get currentUser() {
        const activeUsers = this.users.filter(user => user.state === UserState.Active);
        if (activeUsers.length === 0) {
            return null;
        }
        else {
            // Current user is the top of the stack
            return activeUsers[0];
        }
    }
    /**
     * All active and logged-out users:
     *  - First in the list are active users (ordered by most recent call to switchUser or login)
     *  - Followed by logged out users (also ordered by most recent call to switchUser or login).
     *
     * @returns An array of users active or loggedout users (current user being the first).
     */
    get allUsers() {
        // We need to peek into refresh tokens to avoid cyclic code
        const activeUsers = this.users.filter(user => user.refreshToken !== null);
        const loggedOutUsers = this.users.filter(user => user.refreshToken === null);
        // Returning a freezed copy of the list of users to prevent outside changes
        return Object.freeze([...activeUsers, ...loggedOutUsers]);
    }
    /**
     * Get the location metadata of an app.
     *
     * @returns A promise of the app's location metadata.
     */
    get location() {
        // Initiate the fetch of the location metadata only once per app instance.
        if (!this._location) {
            this._location = this.baseTransport.fetch({
                method: "GET",
                path: `/app/${this.id}/location`,
                ignoreLocation: true,
            });
        }
        return this._location;
    }
    /**
     * Perform the actual login, based on the credentials.
     * Either it decodes the credentials and instantiates a user directly or it calls User.logIn to perform a fetch.
     *
     * @param credentials Credentials to use when logging in
     */
    async performLogIn(credentials) {
        if (credentials.providerType.startsWith("oauth2") &&
            typeof credentials.payload.redirectUrl === "string") {
            // Initiate the OAuth2 and use the next credentials once they're known
            const result = await this.oauth2.initiate(credentials);
            const { userId, accessToken, refreshToken, } = OAuth2Helper.decodeAuthInfo(result.userAuth);
            return this.createOrUpdateUser(userId, accessToken, refreshToken);
        }
        else {
            const { id, accessToken, refreshToken } = await performLogIn(this, credentials);
            return this.createOrUpdateUser(id, accessToken, refreshToken);
        }
    }
    /**
     * Create (and store) a new user or update an existing user's access and refresh tokens.
     * This helps de-duplicating users in the list of users known to the app.
     *
     * @param userId The id of the user.
     * @param accessToken The new access token of the user.
     * @param refreshToken The new refresh token of the user.
     * @returns A new or an existing user.
     */
    createOrUpdateUser(userId, accessToken, refreshToken) {
        const existingUser = this.users.find(u => u.id === userId);
        if (existingUser) {
            // Update the users access and refresh tokens
            existingUser.accessToken = accessToken;
            existingUser.refreshToken = refreshToken;
            return existingUser;
        }
        else {
            // Create and store a new user
            const user = new User({
                app: this,
                id: userId,
                accessToken,
                refreshToken,
            });
            this.users.unshift(user);
            return user;
        }
    }
    /**
     * Restores the state of the app (active and logged-out users) from the storage
     */
    hydrate() {
        try {
            const userIds = this.storage.getUserIds();
            this.users = userIds.map(id => User.hydrate(this, id));
        }
        catch (err) {
            // The storage was corrupted
            this.storage.clear();
            throw err;
        }
    }
}
/**
 * Instances of this class can be passed to the `app.logIn` method to authenticate an end-user.
 */
App.Credentials = Credentials;
/**
 * Default base url to prefix all requests if no baseUrl is specified in the configuration.
 */
App.DEFAULT_BASE_URL = "https://stitch.mongodb.com";

////////////////////////////////////////////////////////////////////////////
const appCache = {};
/**
 * Get or create a singleton Realm App from an id.
 *
 * @param id The Realm App id visible from the MongoDB Realm UI or a configuration.
 * @returns The Realm App instance. Calling this function multiple times with the same id will return the same instance.
 */
function app(id) {
    if (id in appCache) {
        return appCache[id];
    }
    else {
        const instance = new App(id);
        appCache[id] = instance;
        return instance;
    }
}
/**
 * Handle an OAuth 2.0 redirect.
 *
 * @param location An optional location to use (defaults to the windows current location).
 * @param storage Optional storage used to save any results from the location.
 */
function handleAuthRedirect(location = window.location, storage = createDefaultStorage()) {
    try {
        const queryString = location.hash.substr(1); // Strip the initial # from the hash
        OAuth2Helper.handleRedirect(queryString, storage);
    }
    catch (err) {
        // Ensure calling this never throws: It should not interrupt a users flow.
        console.warn(err);
    }
}

export { App, Credentials, User, UserState, app, createDefaultStorage, handleAuthRedirect };
